[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15584295&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the systematic application of engineering principles, methods, and tools to the development and maintainance of high-quality software systems. It involves the design, development, testing, deployment, and maintainance of software products.

Software engineering plays a crucial role in the technology industry. Its importance include:
- It enables the creation of software applications and systems that power various  aspects of modern life including communication, commerce, entertainment and healthcare.
- Driving economic growth: from startups to tech giants effective software engineering practices are essential for business success.
- It enables the creation of systems that automated the process reducing manual work and increasing efficiencies across industries.
- It provides methodologies like Agile, Waterfall, and DevOps which are crucial for managing large teams and complex projects.
- It has made possible the development of the internet and communication technologies, connecting people and business worldwide.


Identify and describe at least three key milestones in the evolution of software engineering.
These milestones reflect the ongoing evolution of software engineering, driven by the need to manage complexity, improve quality, and respond to the dynamic nature of technology and business environments.
- The development of the programming languages eg Fortran, c: Programming languages are formal languages comprising a set of instructions that can be used to produce various kinds of ouput, particularly in the creation of software. They allow humans to communicate with computers in a way that is more abstract and user-friendly than binary machine code. There impact on software engineering include increased abstraction, probability and standardization, productivity and innovation, and specialization and efficiency.

- the advent of structurred programming in the 1970s: Structured programming emerged as a solution to the 'software crisis', where the complexity of software sytems outpaced the ability to manage them effectively. It emphasized the use of control structures such as loops, conditionals, and subroutines to improve the clarity and quality of code. It laid foundation for more sytematic and organized software development reducing the occurence of 'spaghetti code' (unstructured and difficult-to-maintain code), and also influenced the development of programming languages like C, Pascal, and Ada, which supported structured prgramming principes. The milestone marked the begining of software engineering as a disccipline, with a focus on improving the maintability and reliability of software sytems.

- The rise of Agile methodologies in the 2000s: The Agile Manifesto, published in 2001, marked a shift from traditional, rigid software development processes like the waterfall model to more flexible iterative approaches. Agile methodologies emphasize collaboration, customer feedback, and continous improvement through iterative development cycles. It transformed software engineering by promoting faster delivery of software, better alignment with customer needs, and greater adaptability to change. It led to wodespread adoption of frameworks such as Scrum, Kanban, and Extreme Programming (XP). It represents a fundamental change in how software projects are manged and executed, fostering a culture of collaboration and continous delivery that has become standard practice in the industry.

List and briefly explain the phases of the Software Development Life Cycle.
The software development life cycle (SDLC) is a structured process used for developing software applications. It consist of several phases each with specific objectives and tasks.
- Planning: It involves defining the scope, objectives, and resources required for the project. It includes feasibility studies, project scheduling, and cost estimation. It establishes a clear plan that outlines what the software will accomplish and how it will be developed, ensuring that the project is feasible and aligned with the business goals.
- Requirements Analysis: It involves gathering and documenting user needs and system requirements. Objective is to create a detailed list of functional and non-functional requirements that the software must meet, serving as a foundation for the subsequent phases.
- Design: It involves creating a high-level and detailed designs of the software architecture and user interface. Objective is to provide a blueprint for the development team, outlining how the software will be structured and how different components will interact.
- Implementation (Coding/Development): The actual code is written and the software built according to the design specifications. The objective is to build the software by converting the design into a functional application through programming.
- Testing: Involves conducting various tests to ensure the software meets quality standards and functional requirements. Different levels of testing such as system testing, and user acceptance testing (UAT) are conducted. Objective is to identify and fix any issues or bugs in the software, ensuring it funcyions correctly and meets quality standards.
- Deployment: After successful testing, the software is realeased to users and customers. Objective is to make the software available for use, ensuring a smooth transition from development to operational status.
- Maintainance: Involves providing on-going support including dixing buys that were not discovered during testing, making updates and enhancements/adding new features to the software after deployment. Objective is to ensure the software continues to function correctly and remains relevant over time, adapting to new requirements or technologies.
- Evaluation (optional): Assesing the overall success of the project, including reviewing the process, and lessons learned. Objective is to gather insights that can be applied to future projects, improving the efficiency and effectivesness of the SDLC process.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
The choice between Waterfall and Agile dependson the specific needs and circumstances of the project.
- Waterfall: The Model is a linear and sequential approach with distinct phases where each phase of the SDLC must be completed before the next one begins. It has a rigid structure in that once a phase is completed, it's difficult to go back and make changes without affecting subsequebt changes. It emphasizes thorough documentation every stage. Typical phases include Requirement analysis, Design, Implemetation, Testing, Deployment and maintainance, flowing downwards like a waterfall. Managers can predict costs, schedules, and resource needs with more certainity. Appropriate scenario - Waterfall is suitable for projects with well-defined and stable requirements where chnages are unlikely eg large scale infrastructure projects, regulatory compliance systems.
- Agile: Is an iterative and increamental approach focused on flexibility, collaboration and responding to change. The project is divided into small manageable units called iterations or sprints, typically lasting 2-4 weeks. It's designed to accomodate change, with continous feedback loops allowing for ongoing adjustments throughout the project. It emphasizes close collaboration between cross-functional teams and active customer involvement throughout the deployment process. While it doesn't have fixed phases, key activities include Sprint planning, Development, Testing, Review and retrospective. Continous feedback from the customer ensures that the final product closely aligns with their need and expectations. Approriate scenario - Agile is ideal for projects where requirements are likely to evolve, or where the end product is not fully defined at the outset eg custom software development, software startups

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
In a software engineering team, different roles collaborate to ensure the successful delivery of a software project.
- Software Developer: Responsible for writing code based on the requirements and design specifications; implementing software solutions, fixing bugs and improving the software perfomance; reviewing the code to ensure quality, adherence to coding standards, and the identification of potential issues; debugging and troubleshooting; unit testing to ensure that individual components of the software function correctly; collaboration with other team members; documenting the code, APIs, and other technical aspects of the software to ensure that it is understable and maintained by others in the future.

- Quality Assurance (QA) Engineer: Develop test plans, test cases, and test scripts based on the project's requirements and specifications; perform both manual and automated testing to ensure software meets the specified requirements; identify, document and track defects or bugs in the software using bug-tracking tools; perform regression testing after changes are made to ensure that the existing functionaity has not been adversely affected; assess the software performanc; collaborate with developers to understand the software design and functionality, provide feedback and ensure quality issues are addressed; document testing procedures, test results and quality metrics.
- Project Manager: Responsible for planning, execution, and delivery of software projects; coordinates the efforts of the entire software developers team; identify  potential risks to the projects such as technical issues; track the progress of the project against the plan using tools like Gantt charts or Kanban boards; managing the projects budget ensuring that it stays within the allocated financial resources; regurlaly communicate with stakeholders, clients, executives and departments; ensure the project meets overall quality standards; resolving conflicts to maintain team morale; oversee the closing phase upon completion.


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
- Integrated Development Environment: Software suites that provide comprehensive tools for writing, debugging and testing code (eg visual Studio - developed by microsoft, used widely for building applications in various languages including C#, C++, Python). They enhance productivity by providing a comprehensive environment for writing, testing, and debugging code; they offer tools for managing code including project template, file organization; intergrate other development tools such as compilers, interpreters, and build automation tools; have in-built debugging tools that help in identifying and fixing bugs more efficiently; support collaboration where multiple developers can work on the same code base simultaneously.

- Version Control Systems: Software tools for tracking changes to source code and coordinating work among team members (eg Git - most widely used distributed VCS, known for its speed, flexibility, and powerful branching and merging capabilities). They allow multiple developers to work on the same project simultaneously; keep a history of all changes made to th codebase, including who made, when, and how; allow developers to create branches to work on new features, bug fixes or experiments without affecting the main code base; have a backup and recovery by storing the codebase in a VCS; it's a connerstone of continoud integration (CI) practices where code changes are automatically tested and intergrated into the main code base.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
- Changing requirements: requirements may change during the development cycle, leading to scope creep and project delays. One can adopt Agile pratices that embrace changing requirements allowing for iterative developments, schedule regular check-ins with stakeholders to review progress and clarify any uncertainities regarding the requirements.
- Tight deadlines: pressure to deliver software products on schedule can result in rushed development and compromise quality. Prioritize tasks based on importance and urgency, adopt Agile practices like scrum, communicatre clearly with the project manager.
- Technical debt: accrued from shortcuts or suboptimal solutions. It can impede future developments efforts and increasemaintainance costs. One should do regullar reassessment of project goals and timelines.
- Managing complex databases: as the project grow, the codebase can become increasingly complex and difficult to manage. Break down the code into smaller manageble modules or components, employ design patterns to solve common problems in a consisten and reusable way which can simplify the code base.
- Keeping up with evolving technology: new languages, frameworks, and tools keep emerging regularly. Dedicate time to continous learning through online courses, participate in developer communities, attend conferences, experiment with new technologies.
- Debugging and trouble-shooting: can be time-consuming and frustating. Adopt a systematic approach by isolating variables, work with a collegue through pair programming


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
- Unit testing: testing individual components or modules of a software to ensure they work correctly in isolation. They help in early detection of errors, ensure code quality, serve as documentation and facilitate refractoring
- Integration testing: testing interactions between different components or subsytems to ensure they work together as expected. They detect interface issues, improve component compatibility, and reduce intergration risks.
- System testing: testing the entire software system as a whole. It verifies the entire application meets the specified requirements and perform correctly in the intended environment. It validates the entire sytem, provides comprehensive coverage and identify issues that arise in real-world.
- Acceptance testing: testing the software against user requirements to ensure it meets user needs. It validates business needs, ensures readiness for production and build confidence among stakeholders that the software is fit for release.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt Engineering involves carefully crafting the wording, structure, and context of prompts to guide AI in generating accurate, relevant, and useful responses.
from airport models.

Importance 
- Maximizing output quality: a well-crafted prompt can lead to a more accurate and coherent output.
- Enhance user experience: users can interat with AI models more effectively, reducing the need for multiple iterations to achieve desired response.
- Controlling the scope and context: allow users to define the scope of the model's response and provide necessary context.
- Improving efficiency in complexx interactions: it ensures that each step is clearly defined and that the model's output aligns with the user needs.


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Vague prompt - Tell me about AI
Improved prompt - Explain how AI is used for diagnosis and treatment in healthcare.
Why the prompt improved:
- Focused: targeted a specific aspect of AI ( healthcare)
- Clear: specifies the type of examples needed (diagnosis and treatment)
- Concise: provides enough detail to guide the AI effectively, resulting in relevant and targeted response.
